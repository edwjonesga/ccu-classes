# ğŸ—ï¸ **Assignment: TAC to the Future**


---

## ğŸ¯ **Overview**

This assignment is split into two main compiler passes:

1. **TACConversionPass** â€” converts your AST into a clean, linearized Three-Address Code (TAC) intermediate representation.
2. **ASMByteCodeGenerationPass** â€” walks through that TAC and generates real Java `.class` files using the ASM library.

When youâ€™re done, youâ€™ll have a working compiler pipeline that can take simple programs and **produce runnable Java bytecode**.

---

## ğŸ§© **Part 1 â€” TACConversionPass**

### ğŸ§  Objective
Turn your AST into a list of **TAC operations**.  
Each TAC instruction should represent a simple, atomic operation â€” at most one operator and three â€œaddressesâ€ (target, arg1, arg2).

### ğŸ’¡ What to Do
- Implement a `TACConversionPass` class.
- Traverse your existing AST using the visitor pattern.
- For each node, emit TAC instructions (store them in a `List<TACInstruction>`).
- Handle expressions, assignments, control flow, and function calls.

### ğŸ§± Example
#### Source
```java
int x = 5 + 3;
````

#### TAC

```
t1 = 5
t2 = 3
t3 = t1 + t2
x = t3
```

Your TAC objects might look something like this:

```java
new TACInstruction(OpCode.LOAD_CONST, "t1", "5", null);
new TACInstruction(OpCode.LOAD_CONST, "t2", "3", null);
new TACInstruction(OpCode.ADD, "t3", "t1", "t2");
new TACInstruction(OpCode.STORE_VAR, "x", "t3", null);
```

---

## âš™ï¸ **Part 2 â€” ASMByteCodeGenerationPass**

### ğŸ§  Objective

Take your TAC instructions and turn them into **real JVM bytecode** using **ASM**.
This is your compiler backend.

### ğŸ’¡ What to Do

* Implement `ASMByteCodeGenerationPass`.
* Walk through the TAC list.
* For each TAC instruction, emit equivalent ASM bytecode instructions.
* Use the `ClassWriter` and `MethodVisitor` APIs from ASM.
* Save the resulting `.class` file and verify it runs via `java <classname>` or `javap -c`.

### ğŸ§± Example Mapping

| TAC                | Bytecode (ASM equivalent)       |
| ------------------ | ------------------------------- |
| `LOAD_CONST t1, 5` | `mv.visitLdcInsn(5)`            |
| `STORE_VAR x, t3`  | `mv.visitVarInsn(ISTORE, slot)` |
| `ADD t3, t1, t2`   | `mv.visitInsn(IADD)`            |
| `RETURN t3`        | `mv.visitInsn(IRETURN)`         |

### ğŸ§° ASM Quick Reference

| Purpose           | Instruction | ASM API                       |
| ----------------- | ----------- | ----------------------------- |
| Push int constant | `ldc`       | `visitLdcInsn(value)`         |
| Load from local   | `iload`     | `visitVarInsn(ILOAD, index)`  |
| Store to local    | `istore`    | `visitVarInsn(ISTORE, index)` |
| Add two ints      | `iadd`      | `visitInsn(IADD)`             |
| Return int        | `ireturn`   | `visitInsn(IRETURN)`          |

---

## ğŸ§ª **Testing and Verification**

* Use `javap -c <ClassName>.class` to disassemble and inspect your generated bytecode.
* Write a small program (like `int add(int a, int b) { return a + b; }`) and confirm your compiler generates valid JVM code.
* You can load and execute your generated classes directly from Java or using your test harness.

---

## ğŸ§  **Tips**

* Keep your TAC instruction set simple at first (arithmetic + assignments).
* Later, you can extend it to handle conditionals, loops, and method calls.
* Let ASM compute stack sizes for you:
  Use `ClassWriter(COMPUTE_FRAMES | COMPUTE_MAXS)`.
* Comment your bytecode generation logic heavily â€” this is the bridge between theory and reality!

---

## ğŸ§µ **Deliverables**

* `TACConversionPass.java`
* `ASMByteCodeGenerationPass.java`
* Example test programs and generated `.class` files.

---
### âœ… **End Goal**

A pipeline that looks like this:

```
[ AST ]
   â†“
[TACConversionPass]
   â†“
[TAC Instructions]
   â†“
[ASMByteCodeGenerationPass]
   â†“
[JVM Bytecode (.class)]
   â†“
[Runnable Program ğŸ‰]
```
