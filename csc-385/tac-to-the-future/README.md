# üèóÔ∏è **Assignment: TAC to the Future**


---

## üéØ **Overview**

This assignment is split into two main compiler passes:

1. **TACConversionPass** ‚Äî converts your AST into a clean, linearized Three-Address Code (TAC) intermediate representation.
2. **ASMByteCodeGenerationPass** ‚Äî walks through that TAC and generates real Java `.class` files using the ASM library.

When you‚Äôre done, you‚Äôll have a working compiler pipeline that can take simple programs and **produce runnable Java bytecode**.

---

## üß© **Part 1 ‚Äî TACConversionPass**

### üß† Objective
Turn your AST into a list of **TAC operations**.  
Each TAC instruction should represent a simple, atomic operation ‚Äî at most one operator and three ‚Äúaddresses‚Äù (target, arg1, arg2).

### üí° What to Do
- Implement a `TACConversionPass` class.
- Traverse your existing AST using the visitor pattern.
- For each node, emit TAC instructions (store them in a `List<TACInstruction>`).
- Handle expressions, assignments, control flow, and function calls.

### üß± Example
#### Source
```java
int x = 5 + 3;
````

#### TAC

```
t1 = 5
t2 = 3
t3 = t1 + t2
x = t3
```

Your TAC objects might look something like this:

```java
new TACInstruction(OpCode.LOAD_CONST, "t1", "5", null);
new TACInstruction(OpCode.LOAD_CONST, "t2", "3", null);
new TACInstruction(OpCode.ADD, "t3", "t1", "t2");
new TACInstruction(OpCode.STORE_VAR, "x", "t3", null);
```

---

## ‚öôÔ∏è **Part 2 ‚Äî ASMByteCodeGenerationPass**

### üß† Objective

Take your TAC instructions and turn them into **real JVM bytecode** using **ASM**.
This is your compiler backend.

### üí° What to Do

* Implement `ASMByteCodeGenerationPass`.
* Walk through the TAC list.
* For each TAC instruction, emit equivalent ASM bytecode instructions.
* Use the `ClassWriter` and `MethodVisitor` APIs from ASM.
* Save the resulting `.class` file and verify it runs via `java <classname>` or `javap -c`.

### üß± Example Mapping

| TAC                | Bytecode (ASM equivalent)       |
| ------------------ | ------------------------------- |
| `LOAD_CONST t1, 5` | `mv.visitLdcInsn(5)`            |
| `STORE_VAR x, t3`  | `mv.visitVarInsn(ISTORE, slot)` |
| `ADD t3, t1, t2`   | `mv.visitInsn(IADD)`            |
| `RETURN t3`        | `mv.visitInsn(IRETURN)`         |

### üß∞ ASM Quick Reference

| Purpose           | Instruction | ASM API                       |
| ----------------- | ----------- | ----------------------------- |
| Push int constant | `ldc`       | `visitLdcInsn(value)`         |
| Load from local   | `iload`     | `visitVarInsn(ILOAD, index)`  |
| Store to local    | `istore`    | `visitVarInsn(ISTORE, index)` |
| Add two ints      | `iadd`      | `visitInsn(IADD)`             |
| Return int        | `ireturn`   | `visitInsn(IRETURN)`          |

---

## üß™ **Testing and Verification**

* Use `javap -c <ClassName>.class` to disassemble and inspect your generated bytecode.
* Write a small program (like `int add(int a, int b) { return a + b; }`) and confirm your compiler generates valid JVM code.
* You can load and execute your generated classes directly from Java or using your test harness.

---

## üß† **Tips**

* Keep your TAC instruction set simple at first (arithmetic + assignments).
* Later, you can extend it to handle conditionals, loops, and method calls.
* Let ASM compute stack sizes for you:
  Use `ClassWriter(COMPUTE_FRAMES | COMPUTE_MAXS)`.
* Comment your bytecode generation logic heavily ‚Äî this is the bridge between theory and reality!

---

## üßµ **Deliverables**

* `TACConversionPass.java`
* `ASMByteCodeGenerationPass.java`
* Example test programs and generated `.class` files.

---
### ‚úÖ **End Goal**

A pipeline that looks like this:

```
[ AST ]
   ‚Üì
[TACConversionPass]
   ‚Üì
[TAC Instructions]
   ‚Üì
[ASMByteCodeGenerationPass]
   ‚Üì
[JVM Bytecode (.class)]
   ‚Üì
[Runnable Program üéâ]
```
   # üß† Compiler Construction Workshop: ‚ÄúTAC to the Future‚Äù

Welcome, compiler engineers!
Today‚Äôs session will focus on **building the bridge from the AST to executable Java bytecode**.
By the end of this lab, you‚Äôll have a compiler that can emit real `.class` files using ASM ‚Äî including a simple **Hello World** example.

---

## üéØ **Learning Objectives**

1. Understand how to represent **Three-Address Code (TAC)** as an intermediate representation (IR).
2. Implement a **TACConversionPass** that converts your Abstract Syntax Tree (AST) into TAC using the **Visitor pattern**.
3. Implement an **ASMByteCodeGenerationPass** that converts TAC into JVM bytecode using the **ASM library**.
4. Generate a ‚ÄúHello World‚Äù class file using ASM.
5. Write unit tests to verify both passes.

---

## üß© **Phase 1: Define the TAC Representation**

Start by creating a simple internal representation for TAC instructions.

### ‚ú≥Ô∏è Step 1 ‚Äî Create a TAC Instruction Record

```java
public record TACInstruction(OpCode opcode, String target, String arg1, String arg2) {
    public enum OpCode {
        LOAD_CONST, LOAD_VAR, STORE_VAR, ADD, SUB, MUL, DIV, CALL, RETURN
    }
    public void accept(TACVisitor visitor) {
        visitor.visit(this);
    }
}
```

### ‚ú≥Ô∏è Step 2 ‚Äî Define the Visitor Interface

```java
public interface TACVisitor {
    void visit(TACInstruction instruction);
}
```

---

## ‚öôÔ∏è **Phase 2: TAC Conversion Pass (Visitor Pattern)**

The goal of this phase is to **walk your AST** and emit TAC instructions using the **Visitor pattern**.

### ‚ú≥Ô∏è Step 3 ‚Äî Implement TACConversionPass as an ASTNodeVisitor

```java
public class TACConversionPass implements ASTNodeVisitor {
    private final List<TACInstruction> instructions = new ArrayList<>();

    public List<TACInstruction> getInstructions() {
        return instructions;
    }

    // Overloaded visit methods for each node type
    public void visit(AssignmentNode node) {
        node.getExpression().accept(this);
        instructions.add(new TACInstruction(TACInstruction.OpCode.STORE_VAR, node.getVariableName(), node.getExpression().toString(), null));
    }

    public void visit(BinaryOpNode node) {
        node.getLeft().accept(this);
        node.getRight().accept(this);
        instructions.add(new TACInstruction(TACInstruction.OpCode.ADD, "t" + instructions.size(), node.getLeft().toString(), node.getRight().toString()));
    }

    public void visit(LiteralNode node) {
        instructions.add(new TACInstruction(TACInstruction.OpCode.LOAD_CONST, "t" + instructions.size(), node.getValue().toString(), null));
    }

    public List<TACInstruction> convert(ASTNode root) {
        root.accept(this);
        return instructions;
    }
}
```

### ‚ú≥Ô∏è Step 4 ‚Äî Add `accept` Methods to Your AST Nodes

```java
public interface ASTNode {
    void accept(ASTNodeVisitor visitor);
}

public class AssignmentNode implements ASTNode {
    private final String variableName;
    private final ASTNode expression;

    public AssignmentNode(String variableName, ASTNode expression) {
        this.variableName = variableName;
        this.expression = expression;
    }

    public String getVariableName() { return variableName; }
    public ASTNode getExpression() { return expression; }

    @Override
    public void accept(ASTNodeVisitor visitor) {
        if (visitor instanceof TACConversionPass pass) pass.visit(this);
    }
}

public class BinaryOpNode implements ASTNode {
    private final String operator;
    private final ASTNode left, right;

    public BinaryOpNode(String operator, ASTNode left, ASTNode right) {
        this.operator = operator;
        this.left = left;
        this.right = right;
    }

    public ASTNode getLeft() { return left; }
    public ASTNode getRight() { return right; }

    @Override
    public void accept(ASTNodeVisitor visitor) {
        if (visitor instanceof TACConversionPass pass) pass.visit(this);
    }
}

public class LiteralNode implements ASTNode {
    private final int value;

    public LiteralNode(int value) { this.value = value; }
    public int getValue() { return value; }

    @Override
    public void accept(ASTNodeVisitor visitor) {
        if (visitor instanceof TACConversionPass pass) pass.visit(this);
    }
}
```

---

## üí¨ **Phase 3: Hello World ASM Generation**

Before we dive into converting TAC to bytecode, let‚Äôs warm up with a simple ASM example that generates a `HelloWorld.class` file.

### ‚ú≥Ô∏è Step 5 ‚Äî Implement HelloWorldASMGenerator

```java
import org.objectweb.asm.*;
import static org.objectweb.asm.Opcodes.*;

public class HelloWorldASMGenerator {
    public static void main(String[] args) throws Exception {
        ClassWriter cw = new ClassWriter(0);
        cw.visit(V17, ACC_PUBLIC, "HelloWorld", null, "java/lang/Object", null);

        // Constructor
        MethodVisitor init = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
        init.visitCode();
        init.visitVarInsn(ALOAD, 0);
        init.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
        init.visitInsn(RETURN);
        init.visitMaxs(1, 1);
        init.visitEnd();

        // public static void main(String[] args)
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "main", "([Ljava/lang/String;)V", null, null);
        mv.visitCode();

        // System.out.println("Hello, World!");
        mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
        mv.visitLdcInsn("Hello, World!");
        mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);

        mv.visitInsn(RETURN);
        mv.visitMaxs(2, 1);
        mv.visitEnd();

        cw.visitEnd();

        // Write class file
        java.nio.file.Files.write(java.nio.file.Path.of("HelloWorld.class"), cw.toByteArray());
        System.out.println("Generated HelloWorld.class successfully!");
    }
}
```

### ‚úÖ Run It

```bash
javac HelloWorldASMGenerator.java
java HelloWorldASMGenerator
java HelloWorld
```

Output:

```
Hello, World!
```

---

## üß™ **Phase 4: Testing**

### ‚ú≥Ô∏è Step 6 ‚Äî Write Unit Tests for TAC Pass

```java
@Test
public void testSimpleAdditionTAC() {
    ASTNode node = new AssignmentNode("x", new BinaryOpNode("+", new LiteralNode(5), new LiteralNode(3)));
    TACConversionPass pass = new TACConversionPass();
    node.accept(pass);
    List<TACInstruction> tac = pass.getInstructions();

    assertEquals(3, tac.size());
    assertEquals(TACInstruction.OpCode.LOAD_CONST, tac.get(0).opcode());
    assertEquals(TACInstruction.OpCode.ADD, tac.get(2).opcode());
}
```

---

## üß† **Summary**

Your compiler can now:

1. Walk the AST using a proper **Visitor pattern**.
2. Convert nodes to **TAC instructions**.
3. Generate a working `.class` file ‚Äî starting with **Hello World!**.

> ‚ÄúDon‚Äôt fear the stack ‚Äî embrace it. Byte by byte, we‚Äôre building the future.‚Äù üöÄ
